UPSSCHED.CONF(5)
================

NAME
----

upssched.conf - Configuration for upssched timer program

DESCRIPTION
-----------

This file controls the operations of linkman:upssched[8], the timer-based
helper program for linkman:upsmon[8].

IMPORTANT NOTES
---------------

* Contents of this file should be pure ASCII (character codes
  not in range would be ignored with a warning message).

* Command execution is synchronous (with the called tool process in case
  of `EXECUTE` directive, or with the timer process). Consider using your
  system shell abilities like `&` to send long-duration handling to the
  background and let `upssched` timer daemon continue. This should not
  impact `upsmon` daemon, which handles each notification in a separate
  sub-process (and so not a problem for immediate `EXECUTE` events).

CONFIGURATION DIRECTIVES
------------------------

*DEBUG_MIN* 'number'::
Optional. Specify minimal debugging level for `upssched` daemon or client,
e.g. for troubleshooting a deployment without a need to edit consumer
configuration.
+
Note that command-line option `-D` can only increase this verbosity level.
+
Also note that the configuration file is processed line by line, so you
may want to set this option early on.
+
Example:

	DEBUG_MIN 6

*CMDSCRIPT* 'scriptname'::
Required.  This must be above any AT lines.  This script is used to
invoke commands when your timers are triggered.  It receives a single
argument which is the name of the timer that caused it to trigger.

*PIPEFN* 'filename'::
Required.  This sets the file name of the socket which will be used for
interprocess communications.  This should be in a directory where normal
users can't create the file, due to the possibility of symlinking
and other evil.
+
CAUTION: If you are running Solaris or similar, the permissions that
upssched sets on this file *are not enough* to keep you safe.  If
your OS ignores the permissions on a FIFO, then you MUST put this in a
protected directory!
+
NOTE: By default, linkman:upsmon[8] will run `upssched` as whatever user
you have defined with 'RUN_AS_USER'; in linkman:upsmon.conf[5].  Make sure
that user can create files and write to files in the path you use for
'PIPEFN' and 'LOCKFN'.
+
My recommendation: create a special directory for upssched, make it
owned by your upsmon user, then use it for both.
+
The stock version of the upssched.conf ships with PIPEFN disabled
to make you visit this portion of the documentation and think about how
your system works before potentially opening a security hole.

*LOCKFN* 'filename'::
Required.  upssched attempts to create this file in order to avoid a
race condition when two events are dispatched from upsmon at nearly
the same time.  This file will only exist briefly.  It must not be
created by any other process.
+
You should put this in the same directory as PIPEFN.

*AT* 'notifytype' 'upsname' 'command'::
Define a handler for a specific event 'notifytype' on UPS
'upsname'.  'upsname' can be the special value * to apply this
handler to every UPS.
+
This will perform the command 'command' when the 'notifytype'
and 'upsname' match the current activity.  Possible values for
'command' are:

*START-TIMER* 'timername' 'interval';;
Start a timer of 'interval' seconds.  When it triggers, it
will pass the argument 'timername' as an argument to your
CMDSCRIPT. Each invocation starts an independent timer, even
if the 'timername' was already registered and started (note
this can mess up subsequent CANCEL-TIMER operations).
+
Example:
+
Start a timer that will execute when any UPS (+*+) has been
gone for 10 seconds

	AT COMMBAD * START-TIMER upsgone 10

*START-TIMER-SHARED* 'timername' 'interval';;
Start a timer of 'interval' seconds.  When it triggers, it
will pass the argument 'timername' as an argument to your
CMDSCRIPT. Each invocation checks if the 'timername' was already
started, and if so -- appends the current event's `UPSNAME`,
`NOTIFYTYPE` and `NOTIFYMSG` to the list of unique values it
would report via environment variables (as a comma-separated
string for `UPSNAME` and `NOTIFYTYPE`, and tab-separated
sentences for `NOTIFYMSG`) when the timer does execute.
+
NOTE: Currently this updates the first seen instance with the
'timername' (in case you managed to start many).
+
Example:
+
Start a timer that will execute when any UPS (+*+) has been
gone for 10 seconds

	AT COMMBAD * START-TIMER upsgone 10

*CANCEL-TIMER* 'timername' ['cmd'];;
Cancel a running timer called 'timername', if possible.
If the timer has passed then pass the optional argument
'cmd' to CMDSCRIPT.
+
NOTE: This removes the all seen instances with the
'timername' (in case you managed to start many).
+
Example:
+
If a specific UPS (+myups@localhost+) comes back online, then
stop the timer before it triggers

	AT COMMOK myups@localhost CANCEL-TIMER upsgone

*CANCEL-TIMER-MATCHED* 'timername' ['cmd'];;
Similar to the above, but tries to only cancel the 'timername' if it
refers to the `UPSNAME` and `NOTIFYTYPE` values passed by caller.
The `NOTIFYMSG` is ignored in this context.
+
Example:
+
If any UPS (+*+) reverts to utility power, then stop the timer before it
triggers ONLY if that UPS is associated with the already scheduled timer:

	AT ONLINE * CANCEL-TIMER-MATCHED onbattwarn

*EXECUTE* 'command';;
Immediately pass 'command' as an argument to CMDSCRIPT.
+
Example:
+
If any UPS (+*+) reverts to utility power, then execute
`ups-back-on-line` via CMDSCRIPT.

	AT ONLINE * EXECUTE ups-back-on-line

Note that any AT that matches both the 'notifytype' and the
'upsname' for the current event will be used.

For a complete list of 'notifytype' possible values, refer to the section
NOTIFY EVENTS in linkman:upsmon[8].

SEE ALSO
--------

linkman:upssched[8], linkman:upsmon[8]

Internet resources:
~~~~~~~~~~~~~~~~~~~

The NUT (Network UPS Tools) home page: https://www.networkupstools.org/
